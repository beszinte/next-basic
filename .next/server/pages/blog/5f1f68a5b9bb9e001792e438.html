<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>6 Things Programmers Know Are Bad But Still Do Anyway</title><meta name="next-head-count" content="3"/><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/6118e5451f3585d2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6118e5451f3585d2.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/_next/static/chunks/main-9e04412d3480e75f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3313529033c2b732.js" defer=""></script><script src="/_next/static/chunks/814-8ca81627e4bde168.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bid%5D-f73b84008e5cac39.js" defer=""></script><script src="/_next/static/ujjAh6kHG6Sm29kRanXyW/_buildManifest.js" defer=""></script><script src="/_next/static/ujjAh6kHG6Sm29kRanXyW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><div class="header_header__zJOD0"><a href="/"><span class="header_link__ne2MS">Home</span></a><a href="/blog"><span class="header_link__ne2MS">Blog</span></a><a href="/profile"><span class="header_link__ne2MS">Profile</span></a><a href="/blog/items"><span class="header_link__ne2MS">Items</span></a><a href="/blog/categories"><span class="header_link__ne2MS">Categories</span></a><a href="/departements"><span class="header_link__ne2MS">Départements</span></a></div><h1>6 Things Programmers Know Are Bad But Still Do Anyway</h1><div><img src="https://res.cloudinary.com/beloved/image/upload/v1595893925/Udemy/f6mawtvujhkgmjbysary.jpg"/></div><p>
1. Quick and Dirty Solutions
Sometimes you know the solution you chose is suboptimal. However, this suboptimal solution gets implemented because it&#x27;s quick and the code works. This leaves you with more time to fix other stuff. Nothing wrong with that, right?
It feels good to fix a certain problem within a matter of time. But making your code work is only a tiny part of the job. The problem with quick and dirty solutions is that this approach brings some serious deficiencies that lead to more technical debt.
Whenever you bring another one of your quick and dirty solutions to review, you should be aware of the fact that these “solutions” can be devastating for the morale of the team.
In your defense, there might be some cases where quick and dirty may not really matter. It might actually be the right way to go in certain situations (e.g. when code has a short lifespan).
But when you need code for the long run, fixing things in a quick and dirty way will come back to bite you. Don’t justify these solutions by saying that you’ll clean them up later. We’ve all heard that fairy tale before.
2. Silently Swallowing Errors
Silently swallowing errors is a mistake I’ve seen plenty of times from inexperienced developers. However, seasoned developers tend to silently swallow errors as well. And unlike inexperienced developers, they do it on purpose.
When you’ve got loads of stuff to do and deadlines come into play, you don’t have time for every issue that comes rolling into the bug tracker. Instead of being disturbed by all the potential notifications, you sometimes choose to silently swallow the errors. This allows you to focus on all the remaining tasks you still have to do.
Other times, swallowing errors silently happens unintentionally. Some reasons for this can be a lack of experience or not knowing what’s going on in the code on a lower level.
You can think of some use cases where swallowing errors would be preferable (e.g. when creating a log file fails for some reason since there is nowhere to report this).
However, as a rule of thumb, you don’t want to silently swallow errors.
3. Over-Engineering
Implementing certain design patterns for the heck of it is something that most developers have done. Just because you see an opportunity to implement a design pattern doesn’t mean you should.
This is a classic form of over-engineering, and all you’re going to accomplish with it is add more technical depth to the codebase. Over-engineering tends to happen more often when developers aren’t getting challenged enough. When this happens, they start to look for challenges themselves.
Another reason why over-engineering might happen is because of assumptions — the assumption that adding a certain piece of code might be helpful in the future. This additional piece of code gets added to the codebase, but it probably never gets used. Maybe the best way to explain over-engineering is that it is code that solves problems that don’t exist.
</p></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"pictures":["https://res.cloudinary.com/beloved/image/upload/v1595893925/Udemy/f6mawtvujhkgmjbysary.jpg"],"_id":"5f1f68a5b9bb9e001792e438","title":"6 Things Programmers Know Are Bad But Still Do Anyway","body":"There can be various reasons why programmers choose to do these bad things — for the thrill, because of laziness, etc. One thing is certain: You shouldn’t do the things listed in this article too often. Granted, sometimes it just feels good to be bad.","description":"\n1. Quick and Dirty Solutions\nSometimes you know the solution you chose is suboptimal. However, this suboptimal solution gets implemented because it's quick and the code works. This leaves you with more time to fix other stuff. Nothing wrong with that, right?\nIt feels good to fix a certain problem within a matter of time. But making your code work is only a tiny part of the job. The problem with quick and dirty solutions is that this approach brings some serious deficiencies that lead to more technical debt.\nWhenever you bring another one of your quick and dirty solutions to review, you should be aware of the fact that these “solutions” can be devastating for the morale of the team.\nIn your defense, there might be some cases where quick and dirty may not really matter. It might actually be the right way to go in certain situations (e.g. when code has a short lifespan).\nBut when you need code for the long run, fixing things in a quick and dirty way will come back to bite you. Don’t justify these solutions by saying that you’ll clean them up later. We’ve all heard that fairy tale before.\n2. Silently Swallowing Errors\nSilently swallowing errors is a mistake I’ve seen plenty of times from inexperienced developers. However, seasoned developers tend to silently swallow errors as well. And unlike inexperienced developers, they do it on purpose.\nWhen you’ve got loads of stuff to do and deadlines come into play, you don’t have time for every issue that comes rolling into the bug tracker. Instead of being disturbed by all the potential notifications, you sometimes choose to silently swallow the errors. This allows you to focus on all the remaining tasks you still have to do.\nOther times, swallowing errors silently happens unintentionally. Some reasons for this can be a lack of experience or not knowing what’s going on in the code on a lower level.\nYou can think of some use cases where swallowing errors would be preferable (e.g. when creating a log file fails for some reason since there is nowhere to report this).\nHowever, as a rule of thumb, you don’t want to silently swallow errors.\n3. Over-Engineering\nImplementing certain design patterns for the heck of it is something that most developers have done. Just because you see an opportunity to implement a design pattern doesn’t mean you should.\nThis is a classic form of over-engineering, and all you’re going to accomplish with it is add more technical depth to the codebase. Over-engineering tends to happen more often when developers aren’t getting challenged enough. When this happens, they start to look for challenges themselves.\nAnother reason why over-engineering might happen is because of assumptions — the assumption that adding a certain piece of code might be helpful in the future. This additional piece of code gets added to the codebase, but it probably never gets used. Maybe the best way to explain over-engineering is that it is code that solves problems that don’t exist.\n","__v":0}},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"5f1f68a5b9bb9e001792e438"},"buildId":"ujjAh6kHG6Sm29kRanXyW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>